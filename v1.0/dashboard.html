<script>
(function(){
  const $=s=>document.querySelector(s);
  const fmt=n=>new Intl.NumberFormat().format(Math.round(n||0));
  const pct=(num,den)=>den>0?(100*num/den):0;
  const nicePct=v=>`${parseFloat(v||0).toFixed(1)}%`;
  const VAR={
    primary:getComputedStyle(document.documentElement).getPropertyValue('--primary').trim(),
    line:getComputedStyle(document.documentElement).getPropertyValue('--line').trim(),
    text_muted:getComputedStyle(document.documentElement).getPropertyValue('--text-muted').trim()
  };

  let DATA=null;                       // <- don’t render until this is set
  const state={range:'24h',metric:'Reply %',agentType:'All',chartType:'bar'};
  let mainChart=null;

  const METRICS=[
    {label:'Reply %',key:'Reply %',isPct:true, formula:(a)=>`${a.Replies}/${a.Contacted}`},
    {label:'Contacted → Appt/Lead %',key:'Contacted → Appt/Lead %',isPct:true, formula:(a)=>`${a['Appointments / Leads']}/${a.Contacted}`},
    {label:'Appt/Lead → Close %',key:'Appt/Lead → Close %',isPct:true, formula:(a)=>`${a.Sold}/${a['Appointments / Leads']}`},
    {label:'Contacted → Close %',key:'Contacted → Close %',isPct:true, formula:(a)=>`${a.Sold}/${a.Contacted}`}
  ];

  // ---------- helpers that depend on DATA
  const getAgentsForRange=(range)=>{
    if(!DATA) return [];
    const arr=(DATA.agentsByRange?.[range]||[]);
    return arr.map(a=>({
      name:a.agent,
      Contacted:a.outbound||0,
      Replies:a.inbound||0,
      'Appointments / Leads':a.leads||0,
      Sold:a.sold||0
    }));
  };

  const withMetrics = (a)=>({
    ...a,
    'Reply %': pct(a.Replies, a.Contacted),
    'Contacted → Appt/Lead %': pct(a['Appointments / Leads'], a.Contacted),
    'Appt/Lead → Close %': pct(a.Sold, a['Appointments / Leads']),
    'Contacted → Close %': pct(a.Sold, a.Contacted),
  });

  // ---------- renders
  function renderHeader(){
    if(!DATA) return;
    $('#biz-name') && ($('#biz-name').textContent = DATA.company || '—');
    const dt = new Date(DATA.generatedAtUTC || Date.now());
    $('#last-updated') && ($('#last-updated').textContent =
      dt.toLocaleString('en-US',{month:'numeric',day:'numeric',year:'numeric',hour:'numeric',minute:'2-digit'}));
  }

  function populateSelectors(){
    // Range options (stable)
    const rangeEl = $('#range-select');
    if(rangeEl && !rangeEl.dataset.bound){
      rangeEl.innerHTML = `<option value="24h">24h</option><option value="7d">7d</option><option value="30d">30d</option><option value="90d">90d</option>`;
      rangeEl.dataset.bound = '1';
    }

    // Metric options (stable)
    const metricEl = $('#metric-select');
    if(metricEl && !metricEl.dataset.bound){
      metricEl.innerHTML = METRICS.map(m=>`<option>${m.label}</option>`).join('');
      metricEl.dataset.bound = '1';
    }

    // Agent options (depends on DATA + range)
    const agentNames = ['All', ...getAgentsForRange(state.range).map(a=>a.name)];
    const agentEl = $('#agent-select');
    if(agentEl){
      const current = state.agentType;
      agentEl.innerHTML = agentNames.map(n=>`<option ${n===current?'selected':''}>${n}</option>`).join('');
    }
  }

  function renderKPIs(){
    if(!DATA) return;
    const r = DATA.byRange?.[state.range] || {};
    const contacted = r.messages?.outbound || 0;
    const replies   = r.messages?.inbound  || 0;
    const leads     = r.leads  || 0;
    const sold      = r.sold   || 0;

    const cards = [
      { title:'Prospects contacted', big:fmt(contacted) },
      { title:'Replies',             big:fmt(replies), pill:`Reply %: <strong>${nicePct(pct(replies,contacted))}</strong>` },
      { title:'Appointments / Leads',big:fmt(leads),   pill:`Contacted → Appt/Lead %: <strong>${nicePct(pct(leads,contacted))}</strong>` },
      { title:'Closed',              big:fmt(sold),    pill:`Appt/Lead → Close %: <strong>${nicePct(pct(sold,leads))}</strong>` },
    ];
    $('#kpis-grid').innerHTML = cards.map(c=>`
      <div class="kpi"><h4>${c.title}</h4><div class="big">${c.big}</div>${c.pill?`<div class="pill">${c.pill}</div>`:''}</div>
    `).join('');
  }

  function renderMainChart(){
    if(!DATA) return;
    const agents = getAgentsForRange(state.range).map(withMetrics);
    const metric = METRICS.find(m=>m.label===state.metric) || METRICS[0];

    // Donut = distribution by agent for the selected metric
    if(state.chartType==='donut'){
      const categories = agents.map(a=>a.name);
      const values     = agents.map(a=>a[metric.key] || 0);
      const options = {
        series: values,
        chart: { type:'donut', height:350, toolbar:{show:false} },
        labels: categories,
        tooltip: { theme:'dark', y:{ formatter:(val,opts)=>{
          const i=opts.seriesIndex;
          const a=agents[i];
          if(metric.isPct && a) return `${nicePct(val)} (${metric.formula(a)})`;
          return fmt(val);
        }}}
      };
      if(mainChart) mainChart.destroy();
      mainChart = new ApexCharts($('#main-chart-container'), options); mainChart.render();
      return;
    }

    // Bar / Line views
    let categories=[], series=[];
    if(state.agentType==='All'){
      categories = agents.map(a=>a.name);
      series = [{ name:metric.label, data: agents.map(a=>a[metric.key]||0) }];
    }else{
      const a = agents.find(x=>x.name===state.agentType);
      if(!a){ $('#main-chart-container').innerHTML=''; return; }
      categories = ['Contacted','Replies','Appts/Leads','Sold'];
      series = [{ name:a.name, data:[a.Contacted,a.Replies,a['Appointments / Leads'],a.Sold] }];
    }

    const options = {
      series,
      chart:{ type: state.chartType==='line'?'line':'bar', height:350, toolbar:{show:false}, parentHeightOffset:0 },
      plotOptions:{ bar:{ horizontal: state.chartType==='bar-h', borderRadius:6, columnWidth:'55%' } },
      dataLabels:{ enabled:false },
      stroke:{ curve:'smooth', width:3 },
      colors:[VAR.primary],
      grid:{ borderColor:VAR.line, strokeDashArray:4 },
      xaxis:{ categories, labels:{ style:{ colors:VAR.text_muted } }, axisBorder:{show:false}, axisTicks:{show:false} },
      yaxis:{ labels:{ style:{ colors:VAR.text_muted }, formatter:v=> metric.isPct? `${Math.round(v)}%` : fmt(v) } },
      tooltip:{ theme:'dark', y:{ formatter:(val,opts)=>{
        if(state.agentType==='All'){
          const a = agents[opts.dataPointIndex];
          if(metric.isPct && a) return `${nicePct(val)} (${metric.formula(a)})`;
        }else{
          const a = withMetrics({
            name:state.agentType,
            Contacted:series[0].data[0]||0,
            Replies:series[0].data[1]||0,
            'Appointments / Leads':series[0].data[2]||0,
            Sold:series[0].data[3]||0,
          });
          if(metric.isPct && a) return `${nicePct(val)} (${metric.formula(a)})`;
        }
        return fmt(val);
      }}}
    };
    if(mainChart) mainChart.destroy();
    mainChart = new ApexCharts($('#main-chart-container'), options); mainChart.render();
  }

  function renderAllAgentsCard(){
    if(!DATA) return;
    let rows = getAgentsForRange(state.range);
    if(state.agentType!=='All') rows = rows.filter(a=>a.name===state.agentType);
    const totals = rows.reduce((acc,c)=>{ for(const k in c){ if(k!=='name') acc[k]=(acc[k]||0)+c[k]; } return acc; },{});
    const t = withMetrics(totals);
    $('#all-agents-card').innerHTML = `
      <h3 class="panel-title">${state.agentType==='All'?'All Agents*':state.agentType}</h3>
      <div class="stat-row"><span>Contacted</span><span>${fmt(t.Contacted||0)}</span></div>
      <div class="stat-row"><span>Replies</span><span>${fmt(t.Replies||0)}</span></div>
      <div class="stat-row"><span>Appts/Leads</span><span>${fmt(t['Appointments / Leads']||0)}</span></div>
      <div class="stat-row"><span>Sold</span><span>${fmt(t.Sold||0)}</span></div>`;
  }

  function renderPipelineStatus(){
    if(!DATA) return;
    // If single agent selected and auditByAgent exists, use it; else totals
    let list = DATA.auditStatusTotals || [];
    if(state.agentType!=='All' && Array.isArray(DATA.auditByAgent)){
      const row = DATA.auditByAgent.find(r=>r.agent===state.agentType);
      if(row && Array.isArray(row.totals)) list = row.totals.map(x=>({Status:x.Status, Count:x.Count}));
    }
    const total = list.reduce((s,x)=>s+(x.Count||0),0);
    $('#pipeline-status-panel').innerHTML = `
      <h3 class="panel-title">Pipeline Status</h3>
      ${list.map(s=>`<div class="stat-row"><span>${s.Status}</span><span>${fmt(s.Count)} (${nicePct(pct(s.Count,total))})</span></div>`).join('')}
      <div class="stat-row"><span>Total</span><span>${fmt(total)}</span></div>`;
  }

  function renderAll(){
    if(!DATA) return;
    populateSelectors();
    renderHeader();
    renderKPIs();
    renderMainChart();
    renderAllAgentsCard();
    renderPipelineStatus();
  }

  // ---------- public API called by the loader after webhook returns
  window.renderDashboard = function(payload){
    try{
      DATA = (typeof payload==='string') ? JSON.parse(payload||'{}') : (payload||{});
      // reset Agent select to include names from this dataset
      state.agentType = 'All';
      renderAll();
    }catch(e){ console.error('renderDashboard parse error', e); }
  };

  // ---------- wire controls (once)
  document.addEventListener('DOMContentLoaded', ()=>{
    $('#refresh')?.addEventListener('click', ()=> location.reload());
    $('#range-select')?.addEventListener('change', e=>{ state.range=e.target.value; renderAll(); });
    $('#metric-select')?.addEventListener('change', e=>{ state.metric=e.target.value; renderAll(); });
    $('#agent-select')?.addEventListener('change', e=>{ state.agentType=e.target.value; renderAll(); });
    $('#chart-type-select')?.addEventListener('change', e=>{ state.chartType=e.target.value; renderAll(); });
    $('#show-all-btn')?.addEventListener('click', ()=>{ state.agentType='All'; renderAll(); });
    // Don’t render yet — wait for renderDashboard()
  });
})();
</script>
